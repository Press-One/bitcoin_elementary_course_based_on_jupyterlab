{"./":{"url":"./","title":"0 序言","keywords":"","body":"基于 JupyterLab 的比特币极速入门指南 —— 进入区块链世界的绝佳入口 项目主页： https://bitcoin.doge.university 进阶课程地址： https://github.com/albertschr/bitcoin_advanced_course_based_on_jupyterlab 本书适合人群 编程入门者 可能你已经入门了 Python，可能你刚刚学完《自学是门手艺》。那么把这本教程当成你的第一个「进阶项目」吧！你能体会到编程作为「思考辅助工具」的巨大威力。 比特币长期投资者 拿住比特币的关键，其实在于对比特币的理解是 90%，还是 99%，还是 99.99%……任何一个投资者，都有必要去从技术上了解比特币。 想要了解区块链的开发者 你是一名开发者，最近听说了区块链。那么来看这本教程吧！你将体验「闪电入门」的快感。 一段话说明比特币干了什么 比特币将传统的「分布式系统」往前推进一步，实现了「节点可自由进出」的分布式系统，系统的目的是维护一个「历史数据不可篡改的数据库」。 然后，这个不可篡改的数据库用在存储账簿上，于是就成为了一家有「存储」和「转账」业务的「世界银行」。 为什么要以比特币为框架入门区块链？ 比特币是迄今为止为止最成功的区块链项目 比特币的核心足够简洁，符合「奥卡姆剃刀原则」 比特币的文档 / Wiki 很丰富 比特币有 Python 版本的实现，而 Python 版本的源码比较好读 本书涉及的内容 数学、密码学、信息学、分布式系统、Python 编程等。 本书特性 交互性： 本书用 Ipynb 作为载体，包含大量交互式内容。 多层次性： 本书面向多层次的读者。可以作为非计算机工作者了解比特币的入门读物，也可以作为进入区块链行业的计算机工作者的入门教程。 可扩展性： 每一个部分都可以不断扩展，最终形成一棵以比特币原理为根部的「区块链教程之树🌲」。 参考资料 英文版比特币白皮书：https://bitcoin.org/bitcoin.pdf 至今为止最好的翻译 by 李笑来：https://github.com/xiaolai/bitcoin-whitepaper-chinese-translation/blob/master/Bitcoin-Whitepaper-EN-CN.md ECDSA 密码学库: https://github.com/warner/python-ecdsa 精通比特币：http://v1.8btc.com/books/261/master_bitcoin/_book Draveness 博客：https://draveness.me/tag/%E5%8C%BA%E5%9D%97%E9%93%BE 作者联系方式（加我进学习群） 作者微信二维码： 作者公众号： 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"1_Introduction_简介.html":{"url":"1_Introduction_简介.html","title":"1 简介","keywords":"","body":"1 简介（Introduction） 原文与翻译 Commerce on the Internet has come to rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments. While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. The cost of mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there is a broader cost in the loss of ability to make non-reversible payments for non-reversible services. With the possibility of reversal, the need for trust spreads. Merchants must be wary of their customers, hassling them for more information than they would otherwise need. A certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties can be avoided in person by using physical currency, but no mechanism exists to make payments over a communications channel without a trusted party. What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. Transactions that are computationally impractical to reverse would protect sellers from fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In this paper, we propose a solution to the double-spending problem using a peer-to-peer distributed timestamp server to generate computational proof of the chronological order of transactions. The system is secure as long as honest nodes collectively control more CPU power than any cooperating group of attacker nodes. 互联网商业几乎完全依赖金融机构作为可信第三方去处理电子支付。虽然针对大多数交易来说，这个系统还算不错，但，它仍然被基于信任的模型所固有的缺陷所拖累。完全不可逆转的交易实际上并不可能，因为金融机构不能避免仲裁争议。仲裁成本增加了交易成本，进而限制了最小可能交易的规模，且干脆阻止了很多小额支付交易。除此之外，还有更大的成本：系统无法为那些不可逆的服务提供不可逆的支付。逆转的可能性，造成了对于信任的需求无所不在。商家必须提防着他们的顾客，麻烦顾客提供若非如此（如若信任）就并不必要的更多信息。一定比例的欺诈，被认为是不可避免的。这些成本和支付不确定性，虽然在人与人之间直接使用物理货币支付的时候是可以避免的；但，没有任何一个机制能在双方在其中一方不被信任的情况下通过沟通渠道进行支付。 我们真正需要的是一种基于加密证明而非基于信任的电子支付系统，允许任意双方在不需要信任第三方的情况下直接交易。算力保障的不可逆转交易能帮助卖家不被欺诈，而保护买家的日常担保机制也很容易实现。在本论文中，我们将提出一种针对双重支出的解决方案，使用点对点的、分布式的时间戳服务器去生成基于算力的证明，按照时间顺序记录每条交易。此系统是安全的，只要诚实节点总体上相对于相互合作的攻击者掌握更多的 CPU 算力。 解读 本节主要阐述了「区块链支付系统」相对「传统电子支付系统」的优势： 区块链支付系统降低了成本 买家无需提供过多信息，实现了一定程度上的匿名 提出了一种在没有被信任的第三方（中心）的情况下，也能解决双重支付问题的方案 大白话总结，即是： 传统的系统里，我和陌生人交易需要第三方（国家、机构）背书。而在这个系统里，背书的是系统本身的规则。 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"2.1_Transaction_交易_电子货币的定义.html":{"url":"2.1_Transaction_交易_电子货币的定义.html","title":"2.1 Transaction 交易 —— 电子货币的定义","keywords":"","body":"2.1 交易（Transactions）—— 电子货币的定义 原文与翻译 We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership. 我们将一枚电子硬币定义为一个数字签名链。一位所有者将一枚硬币交给另一个人的时候，要通过在这个数字签名链的末尾附加上以下数字签名：上一笔交易的哈希（hash，音译，亦翻译为“散列值”），以及新所有者的公钥。收款人可以通过验证签名去验证数字签名链的所属权。 重要概念解析 哈希（Hash）： 指将一串任意长度的数据通过「哈希函数」（Hash Function）转换出的「固定长度的字符串」，等同于这串数据的「唯一签名」。 通过原始数据可以校验 hash ，也即可以判断签名真实性；但不能通过 hash 还原数据，也即是「不可逆」的。 【Python 知识点】点击链接跳转至《自学是门手艺》相应知识点 值 函数 字符串 # 试试自己生成 hash # -*- encoding: utf-8 -*- import random hash = random.getrandbits(256) # md5 哈希算法 print(\"hash value by md5: %032x\" % hash) import hashlib str_a = \"shatoshi\" # sha256 算法，bitcoin所使用的哈希算法之一 print(\"hash value by sha256: %s\" % hashlib.sha256().hexdigest()) hash value by md5: f4c2070b6d8f71252a44bcbd292d8deb7c695550aa582fb9cda4247df0eccf65 hash value by sha256: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 公钥和私钥（Public Key and Private Key)： 两把相互配套的「数字钥匙」，可用来「加密解密」或「签名验证」。一般来说，公钥是公开的，私钥是所有者保密的。 既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证（本段来自知乎回答：RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密？）。 ↓↓↓以下内容为进阶知识 入门可略过↓↓↓ ECDSA 与 Secp256k1 我们在看比特币加密算法相关的时候会看到 ECDSA 和 Secp256k1 这两个概念，那么这两个又是啥呢？ ECDSA Elliptic Curve Digital Signature Algorithm or ECDSA is a cryptographic algorithm used by Bitcoin to ensure that funds can only be spent by their rightful owners. 椭圆曲线数字签名算法（ECDSA）是一种比特币使用的密码学算法，该算法可确保资产只能被它们合法的拥有者所使用。 私钥、公钥和签名是与 ECDSA 相关的三个重要概念。私钥和公钥的概念刚才已经说过了。现在再说说「签名」这个概念。 签名（Signature）： 一个可以证明「签名行为」发生过的数字/哈希。这个数字来源于一串哈希和私钥的数学运算。和公私钥不同，签名不是定长的，一般长度为 73、72 或 71 个字节。 Secp256k1 Secp256k1 是比特币所使用的椭圆曲线的参数。所以，如果在一篇文章中提到 Secp256k1 签名算法，则可以理解为「使用了 Secp256k1 参数的 ECDSA 算法」。 下面，将用 Python 版本的 ECDSA 库来演示 Secp256k1 的签名 / 验证过程。 # 试试用Secp256k1 加解密 # -*- encoding: utf-8 -*- import binascii from ecdsa import SigningKey from ecdsa.curves import SECP256k1 # 生成签名钥（私钥）、验证钥（前面加上>即是公钥）与签名 signning_key = SigningKey.generate(curve=SECP256k1) verifing_key = signning_key.get_verifying_key() signature = signning_key.sign(b'shatoshi') sk_hex = binascii.hexlify(signning_key.to_string()).decode('utf-8') vk_hex = binascii.hexlify(verifing_key.to_string()).decode('utf-8') sig_hex = binascii.hexlify(signature).decode('utf-8') print(\"sk hex is {0}, len is {1}\".format(sk_hex,len(sk_hex))) # 32 字节的 binary，转换成 16 进制的话字符串长度是 64 print(\"vk hex is {0}, len is {1}\".format(vk_hex,len(vk_hex))) # 64 字节的 binary，转换成 16 进制的话字符串长度是 128 print(\"sig hex is {0}, len is {1}\".format(sig_hex,len(sig_hex))) # 验证钥验证签名 print(verifing_key.verify(signature, b'shatoshi')) verifing_key.verify(signature, b'batoshi') # 错误的签名导致错误抛出 sk hex is 2de61f4440cb795a80fdfd4959001e95df3874f858e51e9a26fa8d5a362bbb82, len is 64 vk hex is f1b3ffe40966091c2571652aba93924be80860680e569e8ee5d712c42b96ee9b79369f3c7a2e80aa68e52acde73a42b8bf341cb5a1b8a1ca441fe7aca3a3578a, len is 128 sig hex is dfe7cf7103a3fbc8c4508f955888ff87c6307050055176a48d4714b7722e1d6c9ce39e5469ea1e493ad60061468057d4ca4483e6caa8833cc7703a9ace2f8232, len is 128 True --------------------------------------------------------------------------- BadSignatureError Traceback (most recent call last) in 20 # 验证钥验证签名 21 print(verifing_key.verify(signature, b'shatoshi')) ---> 22 verifing_key.verify(signature, b'batoshi') # 错误的签名导致错误抛出 /usr/local/lib/python3.7/site-packages/ecdsa/keys.py in verify(self, signature, data, hashfunc, sigdecode) 99 hashfunc = hashfunc or self.default_hashfunc 100 digest = hashfunc(data).digest() --> 101 return self.verify_digest(signature, digest, sigdecode) 102 103 def verify_digest(self, signature, digest, sigdecode=sigdecode_string): /usr/local/lib/python3.7/site-packages/ecdsa/keys.py in verify_digest(self, signature, digest, sigdecode) 111 if self.pubkey.verifies(number, sig): 112 return True --> 113 raise BadSignatureError 114 115 class SigningKey: BadSignatureError: Secp256k1 与 公私钥 的关系 私钥的本质： 私钥的本质是一个数字，这个数字用 16 进制表示的话，长度是 64；转换为字节，是 32 字节（关于 16 进制与字节的补充知识请看这里 :TODO）。 公钥的本质： 用私钥生成Secp256k1曲线上的一个点，将 x 与 y 拼接起来，再在开头加上 > 后得到一个数字，这个数字就是公钥。用 16进制表示的话，长度是 130；转换为字节，是 65 字节。 公钥、私钥与地址的多种形式 虽然公钥、私钥的本质是数字，但是，不同编码方式下，公钥、私钥，还有公钥生成的地址，可以以多种形式呈现。通过这个古老的比特币地址生成网站，我们可以了解到有哪些形式： 私钥 Private key 普通私钥（通过整型、16进制 或者 字节表示） Private key WIF( Wallet Import Format) Private Key WIF Compressed 公钥 Public Key 普通公钥（通过整型、16进制 或者 字节表示） Public Key Compressed 压缩的公钥 【参考】https://bitcoin.stackexchange.com/questions/3059/what-is-a-compressed-bitcoin-key 地址 Bitcoin Address 普通比特币地址，通过 Public Key 生成 Bitcoin Address Compressed 压缩的比特币地址，通过 Public Key Compressed 生成 通过私钥我们可以生成公钥，通过公钥我们可以生成地址，但这两个过程均是不可逆的： (本图来自精通比特币4.1.2：http://v1.8btc.com/books/261/master_bitcoin/_book/4/4.html） 交易类型、Output 与 UTXO 若要理解 UTXO，先要理解 Output；若要理解 Output，先要知道比特币的交易类型。 比特币的交易类型： 比特币的交易有 P2PKH、P2PK、P2SH、P2WPKH 四种类型。我们目前先讲 P2SH 和 P2PKH。 P2SH（TODO） P2PKH PKH： 公钥哈希（Public Key Hash），公钥经过 Sha256 函数加密，再经过 Ripemd160 函数加密，就得到了公钥哈希。公钥函数在开头加上地址版本（Address Version），再经过 Base58Check 函数加密，就会得到比特币地址。 需要注意的是，Sha256 和 Ripemd160 是单向函数，因此可以通过公钥生成公钥哈希，但无法通过公钥哈希还原出公钥；Base58Check 是双向函数，因此可以通过地址得到公钥哈希。 P2PKH： 面向公钥哈希支付，交易需要发送人（sender）提供来自私钥的有效签名与公钥，交易输出脚本（Transaction Output Script）会使用签名和公钥来验证签名是否与公钥哈希匹配。如果匹配，则这笔钱会被支付出去。 Output： 知道以上概念，我们就能把握 Output 的含义： Output 包含两个部分 —— 一个表明表示这个 Output 里有多少比特币的数字与一个公钥脚本。打个比方，就是一个蓄水池与一个水龙头，水龙头需要用一把钥匙打开（签名脚本）。如果钥匙匹配，蓄水池打开，水就变成接收者的了。 ←放水图 UTXO： 知道了 Output，我们便能自然而然地理解 UTXO（Unspent Transaction Output）—— 公钥脚本还没「解锁」，还没放水的 Output。 在 Bitcoin 以及其他使用 UTXO 模型的加密货币中，某一个『账户』中的余额并不是由一个数字表示的，而是由当前区块链网络中所有跟当前『账户』有关的 UTXO 组成的。 上图中所有绿色的交易输出才是 UTXO，红色的交易输出已经被当前『账户』使用了，所以在计算当前账户的余额时只会考虑绿色的交易输出，也就是 UTXO。 —— Draveness 【延伸阅读】 UTXO 与账户余额模型 总结 实际上，区块链系统中有「两条链」。一个个区块头尾相连形成的链是显示的，也即使「Block Chain」；另一条是由「Output」组成的链，这些链的起始是「币基交易（Coinbase Transaction)」，终点则是 UTXO。 把握了第二条链，我们便知道了比特币系统中的资金是如何流动的。 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"2.2_Transaction_交易_交易链的难点.html":{"url":"2.2_Transaction_交易_交易链的难点.html","title":"2.2 Transaction 交易 —— 交易链的难点","keywords":"","body":"2.2 交易（Transactions）—— 交易链的难点 原文与翻译 The problem of course is the payee can't verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank. 这个路径的问题在于收款人无法验证曾经的所有者之中没有人双重支付过。常见的解决方案是引入一个可信的中心化权威方，或称“铸币厂”，让它去检查每一笔交易是否存在双重支付。每一次发生交易之后，硬币必须返回到铸币厂，铸币厂再发行一枚新的硬币。进而，只有铸币厂直接发行的硬币才是可信的、未被双重支付过的。这个解决方案的问题在于，整个货币系统的命运被拴在运营铸币厂的那个公司（就好像银行那样）身上，每一笔交易必须通过它。 We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don't care about later attempts to double-spend. The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced[1], and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received. 我们需要一种方式，可以让收款人确认之前的所有者并没有在任何之前的交易上签名。就我们的目的而言，只有最早的交易是算数的，所以，我们并不关心其后的双重支付企图。确认一笔交易不存在的唯一方法是获悉所有的交易。在铸币厂模型之中，铸币厂已然知悉所有的交易，并且能够确认这些交易的顺序。为了能在没有“被信任的一方”参与的情况下完成以上任务，交易记录必须被公开宣布[1]，进而我们需要一个系统能让参与者们认同它们所接收到的同一个唯一的交易历史。收款人需要证明在每笔交易发生之时，大多数节点能够认同它是第一个被接收的。 [1]: b-money Dai Wei (1998-11-01) http://www.weidai.com/bmoney.txt 解读 对于 2.1 中提到的「交易链」来说，重要的问题是避免「双重支付」。 双重支付： 一个 UTXO，小猪先支付给小兔，这个「交易A」记载了「账本A」上；然后，小猪来到了小狗处，小狗拿着的「账本B」不包含「交易A」，所以小猪又顺利支付。 解决方法是，收款人能在网络上找到这么一个账本（数据库），这个账本中所记载的所有交易的历史都是不可篡改的。那么，收款人自然能检查这笔 UTXO 是否被使用过了。 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"3_TimeStamp_Server_时间戳服务器.html":{"url":"3_TimeStamp_Server_时间戳服务器.html","title":"3 TimeStamp_Server 时间戳服务器","keywords":"","body":"3 时间戳服务器 (Timestamp Server) —— 区块的链 原文与翻译 The solution we propose begins with a timestamp server. A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post[2-5]. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it. 本解决方案起步于一种时间戳服务器。时间戳服务器是这样工作的：为一组（block）记录（items）的哈希打上时间戳，而后把哈希广播出去，就好像一份报纸所做的那样，或者像是在新闻组（Usenet）里的一个帖子那样[2-5]。显然，时间戳能够证明那数据在那个时间点之前已然存在，否则那哈希也就无法生成。每个时间戳在其哈希中包含着之前的时间戳，因此构成了一个链，此条链上的每一个新的时间戳被添加在之前的时间戳之后。 [2]: Design of a secure timestamping service with minimal trust requirements Henri Massias, Xavier Serret-Avila, Jean-Jacques Quisquater 20th Symposium on Information Theory in the Benelux (1999-05) http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228 [3]: How to time-stamp a digital document Stuart Haber, W.Scott Stornetta Journal of Cryptology (1991) https://doi.org/cwwxd4 DOI: 10.1007/bf00196791 [4]: Improving the Efficiency and Reliability of Digital Time-Stamping Dave Bayer, Stuart Haber, W. Scott Stornetta Sequences II (1993) https://doi.org/bn4rpx DOI: 10.1007/978-1-4613-9323-8_24 [5]: Secure names for bit-strings Stuart Haber, W. Scott Stornetta Proceedings of the 4th ACM conference on Computer and communications security - CCS ’97(1997) https://doi.org/dtnrf6 重要概念解析 时间戳 计算机对某一时刻的记录，通常用以区分事件（例如：区块生成）的先后顺序（来源：维基百科）。 时间戳机制的逻辑是这样的：包含时间戳的数据进行哈希运算得到哈希值 -> 不可能在哈希值不变的情况下篡改时间戳 -> 事件必然在时间戳之前发生。 【讨论】时间戳的在区块链中的真正意义？ 【Python 知识点】 点击链接跳转至《自学是门手艺》相应知识点 值——值的类型 # 生成时间戳 import time ts = int(time.time()) print(ts) # 10 位时间戳 1559912492 时间戳服务器 本文中的「时间戳服务器」，实际上就是「出块节点（Block Producter）」，它安装在每一个「矿工」的「矿机」上。 50 行代码构建区块链 只要 50 行 Python 代码，我们就能构建出最小必要模型，实践本节所说的「区块（Block）」之「链（Chain）」。 本段代码出处： https://blog.csdn.net/qiansg123/article/details/80130757 【Python 知识点】 点击链接跳转至《自学是门手艺》相应知识点 函数 —— 关于参数 类 —— Python 的实现 import hashlib as hasher # 定义区块类 class Block: def __init__(self, index, timestamp, data, previous_hash): self.index = index self.timestamp = timestamp self.data = data self.previous_hash = previous_hash self.hash = self.hash_block() def hash_block(self): sha = hasher.sha256() sha.update( bytes( str(self.index) + str(self.timestamp) + str(self.data) + str( self.previous_hash), 'utf-8')) return sha.hexdigest() 比特币真实的区块结构： 上述模型的代码，对字段进行了简化与调整。 import datetime as date # 「创世区块」创建函数 def create_genesis_block(): # Manually construct a block with index 0 and arbitrary previous hash return Block(0, date.datetime.now(), \"Genesis Block\", \"0\") # 生成创世区块 genesis_block = create_genesis_block() print(\"genesis_block height: {}\".format(genesis_block.index)) print(\"genesis_block hash: {}\".format(genesis_block.hash)) genesis_block height: 0 genesis_block hash: 2ccc4063e8fa70ff6b720508eea10c32bbc82672403dbb5a859a4845a4d2e45d 创世区块 创世区块是一条区块链的第一个区块，现在的比特币版本将其标记为第0块（Block Zero）。 【彩蛋】 中本聪在比特币的创世区块中留下了一句话： The Times 03/Jan/2009 Chancellor on brink of second bailout for banks. 这是 2009 年 1 月 3 日那天泰晤士报的首页新闻标题，有人认为中本聪用这个标题暗示了他创建比特币系统的目的。 # 生成下个区块的函数 def next_block(last_block): this_index = last_block.index + 1 this_timestamp = date.datetime.now() this_data = \"Hey! I'm block \" + str(this_index) this_hash = last_block.hash return Block(this_index, this_timestamp, this_data, this_hash) 【Python 知识点】 点击链接跳转至《自学是门手艺》相应知识点 流程控制 —— for 循环 数据容器 —— 列表 # 用上述函数生成 20 个区块，构成区块链 blockchain = [genesis_block] previous_block = blockchain[0] # How many blocks should we add to the chain # after the genesis block num_of_blocks_to_add = 20 # Add blocks to the chain for i in range(0, num_of_blocks_to_add): block_to_add = next_block(previous_block) blockchain.append(block_to_add) previous_block = block_to_add print(\"Block #{} has been added to the blockchain!\".format(block_to_add.index)) print(\"Hash: {}\\n\".format(block_to_add.hash)) Block #1 has been added to the blockchain! Hash: d8b5365fa3ea02116acc6bbd2d9785c4fb8d391f6098aab5081b142c9f295c74 Block #2 has been added to the blockchain! Hash: 3c78096d7b49ad4e1ca0f0e42c9037ab022707c4d17bee7573f5e6279d24efb0 Block #3 has been added to the blockchain! Hash: e8315509fe28382b0e2811bae9032a4dae23c90397019756bcf0b7c475ace8c5 Block #4 has been added to the blockchain! Hash: d64bba31f69356b1ba101f91e651fb3585680f7b03caec271c1af0a1ad23c7d5 Block #5 has been added to the blockchain! Hash: e0a0dc37dbcb800e0191948950ffd0889001001a3d9c6a80935bf94d4b7ab90f Block #6 has been added to the blockchain! Hash: e90da4426196209056803e28e32509bd8307e508866f837e4ec4803cee5c9aef Block #7 has been added to the blockchain! Hash: 7f75467a5410fa792375dd743733cbc22cebb9f8412edc76475848e456fc7e96 Block #8 has been added to the blockchain! Hash: 8b039d7970a3cfe04aff0cf220450fdde0a60a70a97fa8d8c15ce86ed26f44df Block #9 has been added to the blockchain! Hash: 87ef881e25d3bb0ff0e3f47d48f0ace0f42449f2e959d82c1aebb304d63f0fad Block #10 has been added to the blockchain! Hash: e5b24ad7dc290cbcdb1cda272e729ba1e7a6bcc75af7eaf392112245c2bd0643 Block #11 has been added to the blockchain! Hash: 117d94eaccfda466ebf8e48411a780f93f835754c0f2c5b46bcaca0c84785b34 Block #12 has been added to the blockchain! Hash: 338318a077ed63a80588ec2375264c3a80d04d535ddcc7d09776824212744188 Block #13 has been added to the blockchain! Hash: 398a44f9841ce3a98625be2f79c87ff49bd649b02732ea338b7ed6ce6d443b50 Block #14 has been added to the blockchain! Hash: deff3fb9789fb01cedc375cf392d339275dfc2ef08b16953b5163f0456687e8f Block #15 has been added to the blockchain! Hash: 4c10601088713bfeeabea00ee9a884d2a80b920aecac06b0f1667a8ab14df360 Block #16 has been added to the blockchain! Hash: 653ea9eb69bec573597d7e22692b19bd737f6fee340a17debc319ab4f835c6c7 Block #17 has been added to the blockchain! Hash: 9f26ff3537af763a75a53e8810d550cb6edee51aa3b9a00e527d601f841bb4f5 Block #18 has been added to the blockchain! Hash: 2b4767f320d04ff8490e9cb90615316369fac897b9f0776d072ab118d12c9f53 Block #19 has been added to the blockchain! Hash: 1a8d465eb7848132d771a82d6e48ee089e14fcae1ef6d175753d3b3c930e5f64 Block #20 has been added to the blockchain! Hash: 7342b5dc23228ec255d3b561669954d8564c8f9a57598dcc85dbdeef95aa7f98 这种 单项链表结构 ，确保了一旦对过去的区块内容进行篡改，则那个区块之后的所有区块的哈希值都会发生变动。 那么，又如何确保系统中存在一条唯一的合法的链呢？在 5 Network一章中对此有所描述。 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"4_Proof-of-Work_工作量证明.html":{"url":"4_Proof-of-Work_工作量证明.html","title":"4 Proof-of-Work 工作量证明","keywords":"","body":"4 工作量证明 (Proof-of-Work) 原文与翻译 To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back's Hashcash[6], rather than newspaper or Usenet posts. The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash. 为了实现一个基于点对点的分布式时间戳服务器，我们需要使用类似亚当·伯克的哈希现金[6]那样的一个工作证明系统，而不是报纸或者新闻组帖子那样的东西。所谓的工作证明，就是去寻找一个数值；这个数值要满足以下条件：为它提取散列数值之后 —— 例如使用 SHA-256 计算散列数值 —— 这个散列数值必须以一定数量的 0 开头。每增加一个 0 的要求，将使得工作量指数级增加，并且，这个工作量的验证却只需通过计算一个哈希。 For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block's hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it. 在我们的时间戳网络中，我们是这样实现工作证明的：不断在区块之中增加一个随机数（Nonce），直到一个满足条件的数值被找到；这个条件就是，这个区块的哈希以指定数量的 0 开头。一旦 CPU 的耗费算力所获的的结果满足工作证明，那么这个区块将不再能被更改，除非重新完成之前的所有工作量。随着新的区块不断被添加进来，改变当前区块即意味着说要重新完成所有其后区块的工作。 The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added. 工作证明同时解决了如何决定谁能代表大多数做决定的问题。如果所谓的“大多数”是基于“一个 IP 地址一票”的方式决定的话，那么任何一个可以搞定很多 IP 地址的人就可以被认为是“大多数”。工作证明本质上来看，是“一个 CPU（可以理解为一份算力） 一票”。所谓的“大多数决定”是由最长链所代表的，因为被投入最多工作的链就是它。如果大多数 CPU 算力被诚实的节点所控制，那么诚实链成长最为迅速，其速度会远超其他竞争链。为了更改一个已经产生的区块，攻击者将不得不重新完成那个区块以及所有其后区块的的工作证明，而后还要追上并超过诚实节点的工作。后文展示为什么一个被拖延了的攻击者能够追上的可能性将随着区块的不断增加而指数级降低。 To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they're generated too fast, the difficulty increases. 为了应对硬件算力综合的不断增加，以及随着时间推进可能产生的节点参与数量变化，工作证明难度由此决定：基于平均每小时产生的区块数量的一个移动平均值。如果区块生成得过快，那么难度将会增加。 重要概念解析 Nonce 比特币区块中的 nonce 是一个 32 位（4 字节）的字段。有了这个字段，区块的哈希值（一串 16 进制数字）小于或等于目前网络的目标，也即表示矿工实现了某个工作量。这个字段和其它字段是独立的，也即不会影响到其它的字段。 需要注意的是，Nonce 是一个变化的值。可以把它当成比特币系统的一个「操控杆」。正是有了这个操控杆，不管有多少算力投入了这个系统，也能保证平均十分钟出一个块。 Nonce 生成实战 【Python 知识点】 点击链接跳转至《自学是门手艺》相应知识点 函数 流程控制 —— if 语句与 while 循环 import hashlib import random import time text = \"Long bitcoin, short the world.\" # 定义 valid 函数，如果生成的 hash 开头有 zero_num 个零，则 nonce 达到要求 def valid(hash,zero_num): return hash[0: zero_num] == \"0\" * zero_num # 通过随机碰撞💥寻找 Nonce 的函数 def find_nonce(text, zero_num): start = time.time() find = False while not find: nonce = random.randint(1, 10000000) payload = (text + str(nonce)).encode() hash = hashlib.sha256(payload).hexdigest() if valid(hash,zero_num): print(\"sha256({} + text) => {}\".format(nonce, hash)) print(\"nonce is {}\".format(nonce)) end = time.time() print(\"找到 nonce 时间: {}\".format(end-start)) find = True find_nonce(text, 1) sha256(8676133 + text) => 0ae8c647021d4f38c4325fe38f7474ea6b8ceb851632e40eb0abfddcc472e5df nonce is 8676133 找到 nonce 时间: 0.0003352165222167969 find_nonce(text, 2) sha256(4350470 + text) => 00165f427b28a8e8ec8a83e5cab331a43121ef9752a7c821d8a666a4b57f3af9 nonce is 4350470 找到 nonce 时间: 0.002769947052001953 find_nonce(text, 3) sha256(7990813 + text) => 000a4e2d72e1d447f9a564d718434db5eaf5ba2690b42207d952a640bfeb1ef9 nonce is 7990813 找到 nonce 时间: 0.006875276565551758 find_nonce(text, 5) sha256(8812787 + text) => 000007e8cf2efd2ad71a5e207a112c60d35aef3bc227e707727365d6982d3ae2 nonce is 8812787 找到 nonce 时间: 0.07970809936523438 上述实验表现了如下事实： 1）计算 Nonce 需要花费时间进行随机碰撞，但是验证 Nonce 只需要一次哈希运算； 2）调整难度便是调整「出块速度」。 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"5_Network_网络.html":{"url":"5_Network_网络.html","title":"5 Network 网络","keywords":"","body":"5 网络 (Network) 前言 在 Transactions、Timestamp Server、Proof-of-Work 这三节的基础上，Network 这一节简明地阐述了区块链网络的运行机理。 可以说，看懂这四节，就算是「入门」比特币了。 原文与翻译 The steps to run the network are as follows: New transactions are broadcast to all nodes. Each node collects new transactions into a block. Each node works on finding a difficult proof-of-work for its block. When a node finds a proof-of-work, it broadcasts the block to all nodes. Nodes accept the block only if all transactions in it are valid and not already spent. Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash. 运行网络的步骤如下： 所有新的交易向所有节点广播； 每个节点将新交易打包到一个区块； 每个节点开始为此区块找一个具备难度的工作证明； 当某个区块找到其工作证明，它就要将此区块广播给所有节点； 众多其他节点当且只当以下条件满足才会接受这个区块：其中所有的交易都是有效的，且未被双重支付； 众多节点向网络表示自己接受这个区块的方法是，在创建下一个区块的时候，把被接受区块的哈希当作新区块之前的哈希。 Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proof-of-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one. 节点始终认为最长链是正确的那个，且会不断向其添加新数据。若是有两个节点同时向网络广播了两个不同版本的「下一个区块」，有些节点会先接收到其中一个，而另外一些节点会先接收到另外一个。这种情况下，节点将在它们先接收到的那个区块上继续工作，但也会把另外一个分支保存下来，以防后者成为最长链。当下一个工作证明被找到，而其中的一个分支成为更长的链之后，这个暂时的分歧会被打消，在另外一个分支上工作的节点们会切换到更长的链上。 New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one. 新的交易不见得一定要广播到达所有的节点。只要到达足够多的节点，那么没多久这些交易就会被打包进一个区块。区块广播也容许一些消息被丢弃。如果一个节点并未接收到某个区块，那么这个节点会在它接收到下一个区块的时候意识到自己错失了之前的区块，因此会发出补充那个遗失区块的请求。 比特币网络运行步骤大白话版 假设比特币网络里有四个矿工，分别是小猪小兔小狗小鹿小鸟…… 他们四人在接收别人发过来的区块的同时辛勤挖矿…… 突然，小猪和小兔同时挖出了一个 Nonce，都在 12345 这个高度创建了一个区块。他们向全网广播了他们的区块。 小狗和小鹿都先接收到了小猪的区块，又接收到了小兔的区块。于是它们两个在小猪的区块上继续挖矿…… 但是，由于网络问题，小鸟先接收到的是小兔的区块，再接收到的是小猪的区块。于是小鸟在小兔的区块上继续挖矿…… 小鸟的算力比较强劲，它先于小狗和小鹿挖到了块，块高为 12345 + 1 = 12346。它将这个块广播了出去。 其它所有人收到了这个块，然后比较，包含小兔挖到的区块的链的高度 = 12346 > 包含小猪挖到的区块的链 = 12345，所以选择前者，抛弃后者。 如此，就能保证即使有「临时分叉」，但最终「只有一条确定的链」。 在上述区块链网络中，绿色的区块都被包含在主链中，所有黄色的区块都是孤块（Orphan Block），它们没有被主链接受，在每一个区块链网络中只能有一条主链，也就是最长的有效链，也是当前区块链网络中所有节点达成的共识。 ——Draveness 一个可视化理解 PoW 共识机制上的区块链的网站 https://blockchaindemo.io/ 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"6_Incentive_奖励.html":{"url":"6_Incentive_奖励.html","title":"6 Incentive 奖励","keywords":"","body":"6 激励（Incentive） 原文与翻译 By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended. 按照约定，每个区块的第一笔交易是一个特殊的交易，它会生成一枚新的硬币，所属权是这个区块的生成者。这么做，使得节点支持网络有所奖励，也提供了一种将硬币发行到流通之中的方式 —— 在这个系统中，反正也没有一个中心化的权威方去发行那些硬币。如此这般稳定地增加一定数量的新硬币进入流通，就好像是黄金开采者不断耗用他们的资源往流通之中增加黄金一样。在我们的系统中，被耗用的资源是 CPU 工作时间和它们所用的电力。 The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free. 奖励还可以来自交易费用。如果一笔交易的输出值小于它的输入值，那么其中的差额就是交易费；而该交易费就是用来奖励节点把该交易打包进此区块的。一旦既定数量的硬币已经进入流通，那么奖励将全面交由交易手续费来完成，且绝对不会有通货膨胀。 The incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth. 奖励机制也可能会鼓励节点保持诚实。如果一个贪婪的攻击者能够网罗比所有诚实节点都更多的 CPU 算力，他必须做出一个选择：是用这些算力通过把自己花出去的钱偷回来去欺骗别人呢？还是用这些算力去生成新的硬币？他应该能够发现按照规则行事是更划算的，当前规则使得他能够获得比所有其他人加起来都更多的硬币，这显然比暗中摧毁系统并使自己的财富化为虚无更划算。 什么是挖矿？ 挖矿是「通过寻找 Nonce 以获得区块的打包权」。 找到 Nonce，打包了区块后，程序通过造币交易（Coinbase Transaction）生成某个数额的比特币，这些「新币」和交易费作为奖励发给「矿工」。 「挖矿」这个词有一定的误导性。它容易引起对贵重金属采矿的联想，从而使我们的注意力都集中在每个新区快产生的奖励上。尽管挖矿带来的奖励是一种激励，但它最主要的目的并不是奖励本身或者新币的产生。如果只把挖矿看作生产新币的过程，那你是把手段（激励措施）当成了目的。挖矿是一种将结算所去中心化的过程，每个结算所对处理的交易进行验证和结算。挖矿保护了比特币系统的安全，并且实现了在没有中心机构的情况下，也能使整个比特币网络达成共识。 ——《精通比特币》 为什么比特币总数是2100万枚？ 对「新币奖励」的过程有了正确的认知，我们就能明白为什么比特币总数是固定的2100万枚。这是比特币设定的机制决定的——最开始每「开采」一个区块奖励 50 个比特币。之后，每追加 210,000 个区块，货币发行速率降低 50% 。直到每区块发行比特币数量变为比特币的最小货币单位—— 1 聪，这时区块总量会到达 1344 万个，年份是 2140 年左右，彼时比特币的数量就是 2100 万左右了。 一个网站，能看到比特币下次减半是什么时候，以及其它一些有意思的数据—— https://www.bitcoinblockhalf.com/ 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-15 "},"7_Reclaiming_Disk_Space_回收硬盘空间.html":{"url":"7_Reclaiming_Disk_Space_回收硬盘空间.html","title":"7 Reclaiming Disk Space 回收硬盘空间","keywords":"","body":"7 回收硬盘空间（Reclaiming Disk Space） 原文与翻译 Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block's hash, transactions are hashed in a Merkle Tree [2][5][7] , with only the root included in the block's hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored. 如果一枚硬币最近发生的交易发生在足够多的区块之前，那么，这笔交易之前该硬币的花销交易记录可以被丢弃 —— 目的是为了节省磁盘空间。为了在不破坏该区块的哈希的前提下实现此功能，交易记录的哈希将被纳入一个 Merkle 树 [2][5][7] 之中，而只有树根被纳入该区块的哈希之中。通过砍掉树枝方法，老区块即可被压缩。内部的哈希并不需要被保存。 A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes 6 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory. 一个没有任何交易记录的区块头大约是 80 个字节。假设每十分钟产生一个区块，80 字节乘以 6 乘以 24 乘以 365，等于每年 4.2M。截止 2008 年，大多数在售的计算机配有 2GB 内存，而按照摩尔定律的预测，每年会增加 1.2 GB，即便是区块头必须存储在内存之中也不会是什么问题。 [2]: Design of a secure timestamping service with minimal trust requirements Henri Massias, Xavier Serret-Avila, Jean-Jacques Quisquater 20th Symposium on Information Theory in the Benelux (1999-05) http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228 [5]: Secure names for bit-strings Stuart Haber, W. Scott Stornetta Proceedings of the 4th ACM conference on Computer and communications security - CCS ’97(1997) https://doi.org/dtnrf6 DOI: 10.1145/266420.266430 [7]: Protocols for Public Key Cryptosystems Ralph C. Merkle 1980 IEEE Symposium on Security and Privacy (1980-04) https://doi.org/bmvbd6 DOI: 10.1109/sp.1980.10006 Python 实现 Merkle Tree 【Python 知识点】 点击链接跳转至《自学是门手艺》相应知识点 函数 类 数据容器 本实例改自 https://github.com/JaeDukSeo/Simple-Merkle-Tree-in-Python from IPython.display import display, Markdown # 0. Import the needed library import hashlib,json from collections import OrderedDict # 1. Declare the class trees class Jae_MerkTree: # 2. Initiate the class object def __init__(self,listoftransaction=None): self.listoftransaction = listoftransaction self.past_transaction = OrderedDict() # 3. Create the Merkle Tree def create_tree(self): # 3.0 Continue on the declaration listoftransaction = self.listoftransaction past_transaction = self.past_transaction temp_transaction = [] # 3.1 Loop until the list finishes for index in range(0,len(listoftransaction),2): # 3.2 Get the most left element current = listoftransaction[index] # 3.3 If there is still index left get the right of the left most element if index+1 != len(listoftransaction): current_right = listoftransaction[index+1] # 3.4 If we reached the limit of the list then make a empty string else: current_right = '' # 3.5 Apply the Hash 256 function to the current values current_hash = hashlib.sha256(current.encode()) # 3.6 If the current right hash is not a '' # a) Create the new class of Jae_MerkTree Jae_Tree = Jae_MerkTree() # b) Give list of transaction transaction = ['a','b','c','d'] # c) pass on the transaction list Jae_Tree.listoftransaction = transaction # d) Create the Merkle Tree transaction Jae_Tree.create_tree() # e) Retrieve the transaction past_transaction = Jae_Tree.get_past_transacion() # f) Get the last transaction and print all display(Markdown(\"**First Example - Even number of transaction Merkel Tree**\")) display(Markdown('**Final root of the tree:** \\n\\n' + Jae_Tree.get_root_leaf())) display(Markdown(\"**merkle tree:** \\n\\n\" + json.dumps(past_transaction, indent=4))) First Example - Even number of transaction Merkel Tree Final root of the tree: 58c89d709329eb37285837b042ab6ff72c7c8f74de0446b091b6a0131c102cfd merkle tree: { \"a\": \"ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb\", \"b\": \"3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d\", \"c\": \"2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6\", \"d\": \"18ac3e7343f016890c510e93f935261169d9e3f565436429830faf0934f4f8e4\", \"ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d\": \"62af5c3cb8da3e4f25061e829ebeea5c7513c54949115b1acc225930a90154da\", \"2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc618ac3e7343f016890c510e93f935261169d9e3f565436429830faf0934f4f8e4\": \"d3a0f1c792ccf7f1708d5422696263e35755a86917ea76ef9242bd4a8cf4891a\", \"62af5c3cb8da3e4f25061e829ebeea5c7513c54949115b1acc225930a90154dad3a0f1c792ccf7f1708d5422696263e35755a86917ea76ef9242bd4a8cf4891a\": \"58c89d709329eb37285837b042ab6ff72c7c8f74de0446b091b6a0131c102cfd\" } 【小练习】 基于上面的代码，尝试绘制可视化的 Merkle Tree。 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"8_Simplified_Payment_Verification_简化版支付确认.html":{"url":"8_Simplified_Payment_Verification_简化版支付确认.html","title":"8 Simplified Payment Verification 简化版支付确认","keywords":"","body":"8 简化版支付确认（Simplified Payment Verification Privacy） 原文与翻译 It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it. 即便不用运行一个完整网络节点也有可能确认支付。用户只需要有一份拥有工作证明的最长链的区块头拷贝 —— 他可以通过查询在线节点确认自己确实拥有最长链，同时获取一条 Merkle 树的分支 —— 该分支将交易和「将其打上时间戳后置入」的区块连接起来。用户并不能自己检查交易，但，通过将交易连接到链上的某个地方，他可以看到某个网络节点已经接受了这个交易，而此后加进来的区块进一步确认了网络已经接受了此笔交易。 As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker's fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user's software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification. 只要诚实节点依然在掌控网络，如此这般，验证即为可靠的。然而，如果网络被攻击者所控制的时候，验证就没那么可靠了。尽管网络节点可以自己验证交易记录，但是，只要攻击者能够继续控制网络的话，那么简化版验证方式可能会被攻击者伪造的交易记录所欺骗。应对策略之一是，客户端软件要接受来自网络节点的警告。当网络节点发现无效区块的时候，即发出警报，在用户的软件上弹出通知，告知用户下载完整区块，警告用户确认交易一致性。那些有高频收付发生的商家应该仍然希望运行属于自己的完整节点，以此保证更独立的安全性和更快的交易确认。 轻量节点的意义 并非所有的节点都有能力储存完整的区块链。许多比特币客户端被设计成运行在空间和效率受限的设备上，如智能电话、平板电脑、嵌入式系统等。通过简化的支付验证方式可以使它们在不必存储完整区块链的情况下进行工作。 ——《精通比特币》6.7 ：http://v1.8btc.com/books/261/master_bitcoin/_book/6/6.html 轻量节点和全节点的关系 SPV 节点是这样工作的： 根据钱包里的地址，把地址创建以前的区块头全部下载下来； 对于之后的区块，则由全节点提供我们关心的交易（比如发送到我们钱包地址的交易）以及这个交易在某个区块的证明； 关心的交易被记入区块后又有若干个新的区块头，则确信交易已经被确认。 实践 Merkle Tree 交易验证 注： 本图来自 Draveness 的博客 【Python 知识点】 点击链接跳转至《自学是门手艺》相应知识点 函数 流程控制 —— for 循环 import import_ipynb from IPython.display import display, Markdown import hashlib,json import others.merkle_tree as mk_tree display(Markdown(\"**First Example - Even number of transaction Merkel Tree**\")) display(Markdown('**Final root of the tree:** \\n\\n' + mk_tree.Jae_Tree.get_root_leaf())) display(Markdown(\"**merkle tree:** \\n\\n\" + json.dumps(mk_tree.past_transaction, indent=4))) ## ===================== display(Markdown(\"**verify tx by merkle tree:**\")) def verify_tx_by_merkle_tree(tx, leafs, root): current = tx for leaf in leafs: current = hashlib.sha256((current + leaf).encode()).hexdigest() return current==root tx = \"ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb\" tx_2 = \"ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bd\" leafs = [\"3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d\", \"d3a0f1c792ccf7f1708d5422696263e35755a86917ea76ef9242bd4a8cf4891a\"] root = \"58c89d709329eb37285837b042ab6ff72c7c8f74de0446b091b6a0131c102cfd\" print(\"tx 1: \" + str(verify_tx_by_merkle_tree(tx, leafs, root))) print(\"tx 2: \" + str(verify_tx_by_merkle_tree(tx_2, leafs, root))) First Example - Even number of transaction Merkel Tree Final root of the tree: 58c89d709329eb37285837b042ab6ff72c7c8f74de0446b091b6a0131c102cfd merkle tree: { \"a\": \"ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb\", \"b\": \"3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d\", \"c\": \"2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6\", \"d\": \"18ac3e7343f016890c510e93f935261169d9e3f565436429830faf0934f4f8e4\", \"ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d\": \"62af5c3cb8da3e4f25061e829ebeea5c7513c54949115b1acc225930a90154da\", \"2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc618ac3e7343f016890c510e93f935261169d9e3f565436429830faf0934f4f8e4\": \"d3a0f1c792ccf7f1708d5422696263e35755a86917ea76ef9242bd4a8cf4891a\", \"62af5c3cb8da3e4f25061e829ebeea5c7513c54949115b1acc225930a90154dad3a0f1c792ccf7f1708d5422696263e35755a86917ea76ef9242bd4a8cf4891a\": \"58c89d709329eb37285837b042ab6ff72c7c8f74de0446b091b6a0131c102cfd\" } verify tx by merkle tree: tx 1: True tx 2: False 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"9_Combining_and_Splitting_Value_值的组合与分割.html":{"url":"9_Combining_and_Splitting_Value_值的组合与分割.html","title":"9 Combining and Splitting Value 值的组合与分割","keywords":"","body":"9 Combining and Splitting Value（值的组合与分割） 原文与翻译 Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer. To allow value to be split and combined, transactions contain multiple inputs and outputs. Normally there will be either a single input from a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the change, if any, back to the sender. 尽管逐个地处理硬币是可能的，但为每分钱设置一个单独的记录是很笨拙的。为了允许值的分割与合并，交易记录包含多个输入和输出。一般情况下，要么是一个单独的来自于一个相对大的之前的交易的输入，要么是很多个输入来自于更小金额的组合；与此同时，最多有两个输出：一个是支付（指向收款方），如果必要的话，另外一个是找零（指向发款方）。 It should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem here. There is never the need to extract a complete standalone copy of a transaction's history. 值得注意的是，“扇出”在这里并不是问题 —— 所谓“扇出”，就是指一笔交易依赖于数笔交易，且这些交易又依赖于更多笔交易。从来就没有必要去提取任何一笔交易的完整独立的历史拷贝。 比特币的本质——历史记录不可篡改的账本 如果要向完全不了解区块链或者比特币的人用一句话介绍比特币，那么就是这一句—— 比特币的本质是一本「历史记录不可篡改的账本」。 这个账本即由无数的上图所示的交易所组成。 值得注意的是，这个账本里没有传统银行系统所谓的「账户」。 要查一个地址的所有交易记录，那么只要检索所有的历史 Output，找出相关交易即可。 要发送一笔交易，那么只要在「UTXO 池」中找到 Output，用私钥构造交易即可。 通过 bitcoinlib 库实现比特币交易全过程 【Python 知识点】 点击链接跳转至《自学是门手艺》相应知识点 函数 import hashlib from bitcoin import SelectParams from bitcoin.core import b2x, lx, COIN, COutPoint, CMutableTxOut, CMutableTxIn, CMutableTransaction, Hash160 from bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG, SignatureHash, SIGHASH_ALL from bitcoin.core.scripteval import VerifyScript, SCRIPT_VERIFY_P2SH from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret # 通过私钥生成 p2sh 地址 h = hashlib.sha256(b'correct horse battery staple').digest() secret_key = CBitcoinSecret.from_secret_bytes(h) txin_redeemScript = CScript([secret_key.pub, OP_CHECKSIG]) txin_scriptPubKey = txin_redeemScript.to_p2sh_scriptPubKey() txin_p2sh_address = CBitcoinAddress.from_scriptPubKey(txin_scriptPubKey) print('Script Hash 地址:', str(txin_p2sh_address)) Script Hash 地址: 323uf9MgLaSn9T7vDaK1cGAZ2qpvYUuqSp # 构造未签名交易 txid = lx('bff785da9f8169f49be92fa95e31f0890c385bfb1bd24d6b94d7900057c617ae') vout = 0 txin = CMutableTxIn(COutPoint(txid, vout)) print(\"Transaction In: \\n\", txin) txout = CMutableTxOut(10, CBitcoinAddress('323uf9MgLaSn9T7vDaK1cGAZ2qpvYUuqSp').to_scriptPubKey()) print(\"Transaction Out: \\n\", txout) tx = CMutableTransaction([txin], [txout]) print(\"Transaction: \\n\", tx) Transaction In: CTxIn(COutPoint(lx('bff785da9f8169f49be92fa95e31f0890c385bfb1bd24d6b94d7900057c617ae'), 0), CScript([]), 0xffffffff) Transaction Out: CTxOut(0.0000001*COIN, CScript([OP_HASH160, x('03f3814939dfe1b20dffc8965d547950a1493a8a'), OP_EQUAL])) Transaction: CTransaction([CTxIn(COutPoint(lx('bff785da9f8169f49be92fa95e31f0890c385bfb1bd24d6b94d7900057c617ae'), 0), CScript([]), 0xffffffff)], [CTxOut(0.0000001*COIN, CScript([OP_HASH160, x('03f3814939dfe1b20dffc8965d547950a1493a8a'), OP_EQUAL]))], 0, 1, CTxWitness(CTxInWitness(CScriptWitness()))) # 生成签名 sighash = SignatureHash(txin_redeemScript, tx, 0, SIGHASH_ALL) sig = secret_key.sign(sighash) + bytes([SIGHASH_ALL]) # 将签名附加到 txin 中 txin.scriptSig = CScript([sig, txin_redeemScript]) 知识回顾： Output 包含两个部分 —— 一个表明表示这个 Output 里有多少比特币的数字与一个公钥脚本。打个比方，就是一个蓄水池与一个水龙头，水龙头需要用一把钥匙打开（签名脚本）。如果钥匙匹配，蓄水池打开，水就变成接收者的了。 现在我们所做的，即是把 txid 为 bff785da9f8169f49be92fa95e31f0890c385bfb1bd24d6b94d7900057c617ae 的交易的 output，拿来作为新的交易的 input，并通过「钥匙」证明我们能合法的打开这个「水龙头」。 print(b2x(tx.serialize())) 0100000001ae17c6570090d7946b4dd21bfb5b380c89f0315ea92fe99bf469819fda85f7bf000000006c47304402205d99041294db9383056f96582a92fbd47464c13062fcde0dea58b59d2c94397e02204a4c92f0749cd6333f0536e70a7de44d168d9f2302c6619c7163a75507cada740123210378d430274f8c5ec1321338151e9f27f4c676a008bdf8638d07c0b6be9ab35c71acffffffff010a0000000000000017a91403f3814939dfe1b20dffc8965d547950a1493a8a8700000000 上面的这一串十六进制码，就是我们在比特币网络中实际发送的交易了。 延伸阅读 比特币的交易结构： 解析比特币数据.html 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-15 "},"10_Privacy_隐私.html":{"url":"10_Privacy_隐私.html","title":"10 Privacy 隐私","keywords":"","body":"10 隐私（Privacy） 原文与翻译 The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information in another place: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else, but without information linking the transaction to anyone. This is similar to the level of information released by stock exchanges, where the time and size of individual trades, the \"tape\", is made public, but without telling who the parties were. 传统的银行模型通过限制他人获取交易者和可信第三方的信息而达成一定程度的隐私保护。出于对将所有交易记录公开的需求否决了这种方法，但是，维持隐私可通过于另一处的切断信息流来实现——公钥匿名。公众可以看到某个地址向某个地址转了一笔钱，但是，没有任何信息指向某个确定的人。这种水平的信息发布有点像股市交易，只有时间和各个交易的金额被公布，但是，没有人知道交易双方都是谁。 As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner. 还有另外一层防火墙。交易者应该针对每一笔交易启用一对新的公私钥，以便他人无法将这些交易追溯到同一个所有者身上。有些多输入的交易依然难免被追溯，因为那些输入必然会被识别出来自于同一个所有者。危险在于，如果一个公钥的所有者被曝光之后，与之相关的所有其他交易都会被曝光。 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"11_Calculations_计算.html":{"url":"11_Calculations_计算.html","title":"11 Calculations 计算","keywords":"","body":"11 计算（Calculations） 原文与翻译 We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent. 假设一个场景，某个攻击者正在试图生成一个比诚实链更快的替代链。就算他成功了，也不会使当前系统置于模棱两可的尴尬境地，即，他不可能凭空制造出价值，也无法获取从未属于他的钱。网络节点不会把一笔无效交易当作支付，而诚实节点也永远不会接受一个包含这种支付的区块。攻击者最多只能修改属于他自己的交易，进而试图取回他已经花出去的钱（双重支付）。 The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker's chain being extended by one block, reducing the gap by -1. 诚实链和攻击者之间的竞争可以用二项随机漫步来描述。成功事件是诚实链刚刚被添加了一个新的区块，使得它的优势增加了 $1$；而失败事件是攻击者的链刚刚被增加了一个新的区块，使得诚实链的优势减少了 $1$。 The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows8: 攻击者能够从落后局面追平的概率类似于赌徒破产问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率8，如下： $$ \\begin{eqnarray} \\large p &=& \\text{ 诚实节点找到下一个区块的概率}\\ \\ \\large q &=& \\text{ 攻击者找到下一个区块的概率}\\ \\ \\large q_z &=& \\text{ 攻击者落后 $z$ 个区块却依然能够赶上的概率} \\end{eqnarray} $$ $$ \\large q_z = \\begin{Bmatrix} 1 & \\textit{if } p \\leq q\\ \\\\ (q/p)^z & \\textit{if } p > q \\end{Bmatrix} $$ Given our assumption that $p \\gt q$, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind. 既然我们已经假定 $p > q$, 既然攻击者需要赶超的区块数量越来越多，那么其成功概率就会指数级下降。于赢面不利时，如果攻击者没有在起初就能幸运地做一个前移步刺，那么他的胜率将在他进一步落后的同时消弭殆尽。 We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late. 现在考虑一下一笔新交易的收款人需要等多久才能充分确定发款人不能更改这笔交易。我们假定发款人是个攻击者，妄图让收款人在一段时间里相信他已经支付对付款项，随后将这笔钱再转回给自己。发生这种情况时，收款人当然会收到警告，但发款人希望那时木已成舟。 The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction. 收款人生成了一对新的公私钥，而后在签署之前不久将公钥告知发款人。这样可以防止一种情形：发款人提前通过连续运算去准备一条链上的区块，并且只要有足够的运气就会足够领先，直到那时再执行交易。一旦款项已被发出，那个不诚实的发款人开始秘密地在另一条平行链上开工，试图在其中加入一个反向版本的交易。 The recipient waits until the transaction has been added to a block and $z$ blocks have been linked after it. He doesn't know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution with expected value: 收款人等到此笔交易被打包进区块，并已经有 $z$ 个区块随后被加入。他并不知道攻击者的工作进展究竟如何，但是假定诚实区块按照期望的平均速度生成，则攻击者的潜在进展符合泊松分布，其期望值为： $$ \\large \\lambda = z \\frac qp $$ To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point: 为了算出攻击者依然可以赶上的概率，我们要把每一个攻击者已有的进展的泊松密度，乘以他可以从那一点能够追上来的概率： $$ \\large \\sum_{k=0}^{\\infty} \\frac{\\lambda^k e^{-\\lambda}}{k!} \\cdot \\begin{Bmatrix} (q/p)^{(z-k)} & \\textit{if } k\\leq z\\ \\\\ 1 & \\textit{if } k > z \\end{Bmatrix} $$ Rearranging to avoid summing the infinite tail of the distribution... 为了避免对密度分布的无穷级数求和重新整理… $$ \\large 1 - \\sum_{k=0}^{z} \\frac{\\lambda^k e^{-\\lambda}}{k!} \\left ( 1-(q/p)^{(z-k)} \\right ) $$ Converting to C code... 转换为 C 语言程序…… #include double AttackerSuccessProbability(double q, int z) { double p = 1.0 - q; double lambda = z * (q / p); double sum = 1.0; int i, k; for (k = 0; k Running some results, we can see the probability drop off exponentially with $z$. 获取部分结果，我们可以看到概率随着 $z$ 的增加指数级下降： q=0.1 z=0 P=1.0000000 z=1 P=0.2045873 z=2 P=0.0509779 z=3 P=0.0131722 z=4 P=0.0034552 z=5 P=0.0009137 z=6 P=0.0002428 z=7 P=0.0000647 z=8 P=0.0000173 z=9 P=0.0000046 z=10 P=0.0000012 q=0.3 z=0 P=1.0000000 z=5 P=0.1773523 z=10 P=0.0416605 z=15 P=0.0101008 z=20 P=0.0024804 z=25 P=0.0006132 z=30 P=0.0001522 z=35 P=0.0000379 z=40 P=0.0000095 z=45 P=0.0000024 z=50 P=0.0000006 Solving for P less than 0.1%... 若是 P 小于 0.1%…… P [8] An Introduction to Probability Theory and its Applications* William Feller John Wiley & Sons* (1957) https://archive.org/details/AnIntroductionToProbabilityTheoryAndItsApplicationsVolume1 赌徒破产问题 这是一个题外话，但因为是一个很有意义的主题，所以还是插入到了这里…… 假设有两个人玩公平的抛硬币赌输赢的游戏，规则是： 赌注大小恒定 直至一方输光游戏才能结束 请问，最终决定输赢的是什么（单选）？ A.手气 B.谁先抛硬币 C.抛硬币次数 D.总游戏时长 E.以上皆是 F.以上皆不是 答案是什么？这篇文章对此做了很清晰的阐述—— 理财：别做险盲 赌博破产问题 Python 模拟 调整以下代码中的参数，会发现一些有意思的结果。例如—— 把 round_num 改成 1000 试试 庄家来一点「抽水」 【Python 知识点】 点击链接跳转至《自学是门手艺》相应知识点 函数 流程控制 —— for 循环 import random ''' 抛硬币游戏： 抛硬币，正反两面概率各50%，正面你赢，反面庄家赢。 10位玩家，赌本10元，进行100轮。 ''' round_num = 10 person_num = 10 player_total_win_money = 0 for person in range(1,person_num + 1): gambling_money = 10 for r in range(1,round_num + 1): coin = random.randint(0, 1) # 0为正，1为反 if coin == 0 : gambling_money = gambling_money + 1 elif coin == 1 : gambling_money = gambling_money - 1 if gambling_money == 0 : # 因破产而退出赌博 break else: pass player_total_win_money += gambling_money - 10 print(\"第 {} 号玩家经过 {} 轮赌博，最后的资产为 {} 元\".format(person,r,gambling_money)) print(\"=========\") if player_total_win_money > 0: print(\"玩家赢！赢了：{} 元\".format(player_total_win_money)) elif player_total_win_money 第 1 号玩家经过 10 轮赌博，最后的资产为 4 元 第 2 号玩家经过 10 轮赌博，最后的资产为 6 元 第 3 号玩家经过 10 轮赌博，最后的资产为 6 元 第 4 号玩家经过 10 轮赌博，最后的资产为 0 元 第 5 号玩家经过 10 轮赌博，最后的资产为 12 元 第 6 号玩家经过 10 轮赌博，最后的资产为 6 元 第 7 号玩家经过 10 轮赌博，最后的资产为 12 元 第 8 号玩家经过 10 轮赌博，最后的资产为 8 元 第 9 号玩家经过 10 轮赌博，最后的资产为 12 元 第 10 号玩家经过 10 轮赌博，最后的资产为 8 元 ========= 庄家赢！赢了：26 元 数学概念解析 二项随机漫步 如图所示，本节中的「二项随机漫步」可以看做两个人在玩大富翁游戏。在落后 z 步的情况下丢骰子，如果骰数大于 x ，则攻击者前进一步；如果骰数小于 x ，则诚实节点前进一步。 泊松分布 泊松分布适合于描述单位时间内随机事件发生的次数的概率分布。如： 某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA 序列的变异数、放射性原子核的衰变数、激光的光子数分布等等。 攻击链延长的数量（进展）同样符合泊松分布。 延伸阅读 如果读到这里还是觉得不懂，可以看这个链接，描述得很详细： https://zhuanlan.zhihu.com/p/56151888 攻击者追块概率计算 Python 版 【Python 知识点】 math库文档 import math def attacker_success_probability(q, z): sum = 1.0 p = 1.0 - q lamba = z * (q / p) i = 0; k = 0; for k in range(z + 1): poisson = math.exp(-lamba) for i in range(1, k + 1): poisson *= (lamba / i) sum -= poisson * (1 - pow(q / p, z - k)) return sum q= 0.1 print(\"q = {}\".format(q)) for z in range(0,10): prob = attacker_success_probability(q, z) print(\" z = {}, P = {:.10f}\".format(z, prob)) q = 0.1 z = 0, P = 1.0000000000 z = 1, P = 0.2045872739 z = 2, P = 0.0509778928 z = 3, P = 0.0131722417 z = 4, P = 0.0034552435 z = 5, P = 0.0009136822 z = 6, P = 0.0002428027 z = 7, P = 0.0000647353 z = 8, P = 0.0000172998 z = 9, P = 0.0000046312 q= 0.3 print(\"q = {}\".format(q)) for z in range(0,50,5): prob = attacker_success_probability(q, z) print(\" z = {}, P = {:.10f}\".format(z, prob)) q = 0.3 z = 0, P = 1.0000000000 z = 5, P = 0.1773523114 z = 10, P = 0.0416604800 z = 15, P = 0.0101007622 z = 20, P = 0.0024803982 z = 25, P = 0.0006132284 z = 30, P = 0.0001522339 z = 35, P = 0.0000378958 z = 40, P = 0.0000094517 z = 45, P = 0.0000023608 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-15 "},"12_Conclusion_结论.html":{"url":"12_Conclusion_结论.html","title":"12 Conclusion 结论","keywords":"","body":"12 结论（Conclusion） 原文与翻译 We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism. 我们提出了一个不必依赖信任的电子交易系统。起点是一个普通的使用数字签名的硬币框架开始，虽然它提供了健壮的所有权控制，却无法避免双重支付。为了解决这个问题，我们提出一个使用工作证明机制的点对点网络去记录一个公开的交易记录历史，只要诚实节点能够控制大多数 CPU 算力，那么攻击者就仅从算力方面就不可能成功篡改系统。这个网络的健壮在于它的无结构的简单。节点们可以在很少协同的情况下瞬间同时工作。它们甚至不需要被辨认，因为消息的路径并非取决于特定的终点；消息只需要被以最大努力为基本去传播即可。节点来去自由，重新加入时，只需要接受工作证明链，作为它们离线之时所发生之一切的证明。它们通过它们的 CPU 算力投票，通过不断为链添加新的有效区块、拒绝无效区块，去表示它们对有效交易的接受与否。任何必要的规则和奖励都可以通过这个共识机制来强制实施。 一点私人感悟 经过 10 多年的发展，比特币已经由当初的「社会实验」变成了一个异常成功的「银行系统」，甚至由此延伸出了一整个被称作「区块链」的世界。 未来会如何演进？我们难以做出预测。但是，来自未来的风已经吹起来了。 这本教程一方面写给自己，因为我始终坚信，搞懂比特币是搞懂区块链的基础； 另一方面，也是写给所有有志于进入区块链世界的探险者们，愿大家能从这个入口了解这个全新的世界，在这个全新的世界里开疆拓土。 进阶课程 基于 JupyterLab 的比特币教程（进阶） 目录 前言 优质的比特币保存方案 P2SH 与多重签名 比特币升级之路 大区块方案 隔离见证 分布式系统与比特币 传统分布式系统简史 BFT 家族 BFT 与 PoW 【思考】传统 BFT 能简单的移植吗？ PoS DPoS 比特币二层网络 闪电⚡️网络 其它二层网络项目 【概念辨析】Complexity_复杂度 【概念辨析】Throughputand_Latency吞吐与延迟 【可能的未来】Move 与 Libra 比特币相关资源 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "},"【附2】比特币相关网站.html":{"url":"【附2】比特币相关网站.html","title":"【附2】比特币相关网站","keywords":"","body":"比特币相关网站 币 CoinmarketCap —— 查看数字货币的排名与基本信息： https://coinmarketcap.com/ 支持比特币等九种数字货币的浏览器： https://blockchair.com/ 比特币富豪榜及分布现状： https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html 比特币 24 小时交易数据： https://bitinfocharts.com/zh/bitcoin/explorer/ 比特币活跃地址统计： https://bitinfocharts.com/comparison/activeaddresses-btc.html 比特币沉睡地址统计： https://bitinfocharts.com/top-100-dormant_5y-bitcoin-addresses.html 链 比特币地址生成： https://www.bitaddress.org/ 多版本源码： 比特币 C++ 源码： https://github.com/bitcoin/bitcoin 比特币 Python 源码 https://github.com/petertodd/python-bitcoinlib 比特币 Golang 源码 https://github.com/btcsuite/btcd 比特币 Rust 源码 https://github.com/rust-bitcoin/rust-bitcoin 比特币改进建议： https://github.com/bitcoin/bips 比特核心（Bitcoin Core）——比特币开发团队： 官网： https://bitcoin.org/en/bitcoin-core 论坛： https://bitcointalk.org 比特币闪电网络（Lightning Network）开发团队： https://blockstream.com/ 矿 比特币减半数据： https://www.bitcoinblockhalf.com/ 矿池份额等数据： https://explorer.viabtc.com/btc/pool?tabs=0 挖矿计算器： https://btc.com/tools/mining-calculator 李大狗 Leeduckgo © 2019 all right reserved，powered by GitbookLast Modified: 2019-09-05 "}}